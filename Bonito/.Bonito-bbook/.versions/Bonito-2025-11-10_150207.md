# New Book

```julia (editor=true, logging=false, output=true)
using Bonito, Tables
import Pkg; Pkg.activate("C:/Users/Hussin/Documents/GitHub/RPGSimulator.jl") # Quand ce sera le final on pourra l'enlever
using RPGSimulator

# Création des personnages
archer = Archer(nom="Jed")
archer.stats = Stats(PV=100, PM=20, ATK=30, VITESSE=40, DEFENSE=10)

gobelin = Gobelin(nom="Hussin")
gobelin.stats = Stats(PV=120, PM=0, ATK=35, VITESSE=40, DEFENSE=5)

# Simulation de 5 combats
all_logs, summary = simulate_many!(archer, gobelin, N=5, out_dir="data")

# Affichage résumé des combats
Bonito.DOM.div(
    Bonito.DOM.h2("Résumé des combats"),
    Bonito.Table(summary)
)

```
```julia (editor=true, logging=false, output=true)
# Création des personnages
archer = Archer(nom="Jed")
archer.stats = Stats(PV=100, PM=20, ATK=30, VITESSE=40, DEFENSE=10)

gobelin = Gobelin(nom="Hussin")
gobelin.stats = Stats(PV=120, PM=0, ATK=35, VITESSE=40, DEFENSE=5)

# Simulation de 5 combats
all_logs, summary = simulate_many!(archer, gobelin, N=5, out_dir="data")

# Préparation des données PV par round
pv = DataFrame(combat=all_logs.combat, round=all_logs.round, actor=all_logs.actor, pv=all_logs.actor_PV)

# Affichage points de vie par round
Bonito.DOM.div(
    Bonito.DOM.h2("Points de vie par round"),
    Bonito.Table(pv)
)

```
```julia (editor=true, logging=false, output=true)
# Simulation / exemple de données DEFENSE par round
defense_data = DataFrame(combat=Int[], round=Int[], actor=String[], defense=Int[])

# Simule données pour 2 personnages sur 5 rounds
for combat_id in 1:3
    for round in 0:5
        push!(defense_data, (combat_id, round, "Jed", max(10, 20 - round)))
        push!(defense_data, (combat_id, round, "Hussin", max(5, 15 - 2*round)))
    end
end

# Affichage avec Bonito
Bonito.DOM.div(
    Bonito.DOM.h2("Défense par round"),
    Bonito.Table(defense_data)
)

```
```julia (editor=true, logging=false, output=true)
using CSV, DataFrames, Statistics
using Bonito, Tables
using Plots
Plots.plotlyjs()  # Backend interactif

include("../Examples/test.jl")

# --- Création des personnages ---
archer = Archer(nom="Jed")
archer.stats = Stats(PV=100, PM=20, ATK=30, VITESSE=40, DEFENSE=10)

gobelin = Gobelin(nom="Hussin")
gobelin.stats = Stats(PV=120, PM=0, ATK=35, VITESSE=40, DEFENSE=5)

# --- Simulation de 5 combats ---
all_logs, summary = simulate_many!(archer, gobelin, N=5, out_dir="data")

# --- Exemple : colonne DEFENSE pour le graphique ---
all_logs.defense = [archer.stats.DEFENSE for i in 1:nrow(all_logs)]
all_logs.defense[end÷2:end] .= gobelin.stats.DEFENSE

# --- Calcul défense moyenne par round et acteur ---
defense_summary = combine(groupby(all_logs, [:actor, :round]), :defense => mean)

# --- Création du graphique ---
fig = Plots.plot(title="Défense moyenne par round", xlabel="Round", ylabel="Défense")
for name in unique(defense_summary.actor)
    sub = filter(:actor => ==(name), defense_summary)
    Plots.plot!(fig, sub.round, sub.defense_mean, label=name, marker=:circle, linewidth=2)
end

# --- Export HTML pour inclusion dans Bonito ---
html_file = "defense_plot.html"
Plots.savefig(fig, html_file)  # sauvegarde en HTML interactif

# Sauvegarde en image
Plots.savefig(fig, "defense_plot.svg")  # PNG interactif limité, mais visible

# Affichage dans Bonito
Bonito.DOM.div(
    Bonito.DOM.h2("Résumé des combats"),
    Bonito.Table(summary),
    Bonito.DOM.h2("Défense moyenne par round"),
    Bonito.DOM.img(src="defense_plot.svg", width="800px")
)


```
```julia (editor=true, logging=false, output=true)
using WGLMakie
using Bonito
include("../Examples/test.jl")

# --- Crée les personnages ---
archer = Archer(nom="Jed")
archer.stats = Stats(PV=100, PM=20, ATK=30, VITESSE=40, DEFENSE=10)

gobelin = Gobelin(nom="Hussin")
gobelin.stats = Stats(PV=120, PM=0, ATK=35, VITESSE=40, DEFENSE=5)

# --- Simuler 5 combats ---
all_logs, summary = simulate_many!(archer, gobelin, N=5, out_dir="data")
all_logs.defense = [archer.stats.DEFENSE for i in 1:nrow(all_logs)]
all_logs.defense[end÷2:end] .= gobelin.stats.DEFENSE

defense_summary = combine(groupby(all_logs, [:actor, :round]), :defense => mean)

# --- Figure WGLMakie ---
fig = WGLMakie.Figure(resolution=(700,400))
ax = WGLMakie.Axis(fig[1,1], title="Défense moyenne par round", xlabel="Round", ylabel="Défense")

colors = Dict("Jed" => :blue, "Hussin" => :red)
lines_dict = Dict{String, WGLMakie.Lines}()

for name in unique(defense_summary.actor)
    sub = filter(:actor => ==(name), defense_summary)
    lines_dict[name] = WGLMakie.lines!(ax, sub.round, sub.defense_mean, color=colors[name], label=name)
end
WGLMakie.axislegend(ax)

# --- Sérialisation pour le web (obligatoire pour BonitoBook) ---
html_fig = WGLMakie.serialize_scene(fig)

# --- Affichage dans BonitoBook ---
Bonito.DOM.div(
    Bonito.DOM.h2("Défense moyenne par round"),
    Bonito.DOM.rawhtml(html_fig);
    style=Styles("padding" => "20px")
)

```
```julia (editor=true, logging=false, output=true)
using Bonito
using WGLMakie
using Observables

WGLMakie.activate!(; resize_to_body=true)

function interactive_pv_simulation()
    # Observables pour Jed
    pv_jed  = Observable(100)
    atk_jed = Observable(30)
    def_jed = Observable(10)

    # Observables pour Gobelin
    pv_gob  = Observable(120)
    atk_gob = Observable(25)
    def_gob = Observable(5)

    # Observables pour les lignes
    xdata = Observable(Float64[])
    ydata_jed = Observable(Float64[])
    ydata_gob = Observable(Float64[])

    # Figure principale
    fig = Figure(resolution = (900, 600))
    
    # Graphique
    ax = Axis(fig[1,1], title="Évolution des PV", xlabel="Round", ylabel="PV")

    # Dézoom initial sur les deux axes
    ax.limits[] = ((0, 3), (0, 600))  # X: 0-3 rounds, Y: 0-600 PV

    # Lignes de PV
    line_jed = lines!(ax, xdata, ydata_jed; color=:blue, linewidth=2)
    line_gob = lines!(ax, xdata, ydata_gob; color=:red, linewidth=2)

    # Légende
    Legend(fig[1,2], [line_jed, line_gob], ["Jed (Archer)", "Gobelin"])

    # Fonction PV par round
    function compute_pv_traj(pv, atk, defn; rounds=3)
        traj = Float64[]
        current = pv
        push!(traj, current)
        for r in 1:rounds
            dmg = max(0, atk - defn)
            current = max(current - dmg, 0)
            push!(traj, current)
        end
        return 0:rounds, traj
    end

    # Mise à jour réactive
    function update_lines!()
        rounds, traj_jed = compute_pv_traj(pv_jed[], atk_gob[], def_jed[], rounds=3)
        _, traj_gob = compute_pv_traj(pv_gob[], atk_jed[], def_gob[], rounds=3)
        xdata[] = collect(rounds)
        ydata_jed[] = traj_jed
        ydata_gob[] = traj_gob
    end

    # SliderGrid pour Jed
    sg_jed = SliderGrid(
        fig[2,1],
        (label="Jed PV", range=0:500, startvalue=pv_jed[]),
        (label="Jed ATK", range=0:100, startvalue=atk_jed[]),
        (label="Jed DEF", range=0:100, startvalue=def_jed[])
    )
    sPV_jed, sATK_jed, sDEF_jed = sg_jed.sliders
    on(sPV_jed.value)  do v pv_jed[] = v; update_lines!() end
    on(sATK_jed.value) do v atk_jed[] = v; update_lines!() end
    on(sDEF_jed.value) do v def_jed[] = v; update_lines!() end

    # SliderGrid pour Gobelin
    sg_gob = SliderGrid(
        fig[3,1],
        (label="Gob PV", range=0:500, startvalue=pv_gob[]),
        (label="Gob ATK", range=0:100, startvalue=atk_gob[]),
        (label="Gob DEF", range=0:100, startvalue=def_gob[])
    )
    sPV_gob, sATK_gob, sDEF_gob = sg_gob.sliders
    on(sPV_gob.value)  do v pv_gob[] = v; update_lines!() end
    on(sATK_gob.value) do v atk_gob[] = v; update_lines!() end
    on(sDEF_gob.value) do v def_gob[] = v; update_lines!() end

    # Initialiser le graphique
    update_lines!()

    return Bonito.DOM.div(
        Bonito.DOM.h3("Simulateur : Jed vs Gobelin"),
        sg_jed,
        sg_gob,
        fig
    )
end

Bonito.DOM.div(
    Bonito.DOM.h2("Simulation de PV interactive"),
    interactive_pv_simulation()
)

```
```julia (editor=true, logging=false, output=true)
using Bonito
using WGLMakie
using Observables

WGLMakie.activate!(; resize_to_body=true)

function interactive_pv_simulation()
    # Observables pour Jed
    pv_jed  = Observable(100)
    atk_jed = Observable(30)
    def_jed = Observable(10)

    # Observables pour Gobelin
    pv_gob  = Observable(120)
    atk_gob = Observable(25)
    def_gob = Observable(5)

    # Observables pour les lignes
    xdata = Observable(Float64[])
    ydata_jed = Observable(Float64[])
    ydata_gob = Observable(Float64[])

    # Figure principale
    fig = Figure(resolution = (900, 600))
    
    # Graphique
    ax = Axis(fig[1,1], title="Évolution des PV", xlabel="Round", ylabel="PV")
    
    # Fixer limite Y dès le départ (dézoomé)
    ax.limits[] = ((0, 3), (0, 600))  # 0-3 rounds sur X, 0-600 PV sur Y

    # Lignes de PV
    line_jed = lines!(ax, xdata, ydata_jed; color=:blue, linewidth=2)
    line_gob = lines!(ax, xdata, ydata_gob; color=:red, linewidth=2)

    # Légende
    Legend(fig[1,2], [line_jed, line_gob], ["Jed (Archer)", "Gobelin"])

    # Fonction PV par round (3 rounds)
    function compute_pv_traj(pv, atk, defn; rounds=3)
        traj = Float64[]
        current = pv
        push!(traj, current)
        for r in 1:rounds
            dmg = max(0, atk - defn)
            current = max(current - dmg, 0)
            push!(traj, current)
        end
        return 0:rounds, traj
    end

    # Mise à jour réactive
    function update_lines!()
        rounds, traj_jed = compute_pv_traj(pv_jed[], atk_gob[], def_jed[], rounds=3)
        _, traj_gob = compute_pv_traj(pv_gob[], atk_jed[], def_gob[], rounds=3)
        xdata[] = collect(rounds)
        ydata_jed[] = traj_jed
        ydata_gob[] = traj_gob
    end

    # SliderGrid pour Jed
    sg_jed = SliderGrid(
        fig[2,1],
        (label="Jed PV", range=0:500, startvalue=pv_jed[]),
        (label="Jed ATK", range=0:100, startvalue=atk_jed[]),
        (label="Jed DEF", range=0:100, startvalue=def_jed[])
    )
    sPV_jed, sATK_jed, sDEF_jed = sg_jed.sliders
    on(sPV_jed.value)  do v pv_jed[] = v; update_lines!() end
    on(sATK_jed.value) do v atk_jed[] = v; update_lines!() end
    on(sDEF_jed.value) do v def_jed[] = v; update_lines!() end

    # SliderGrid pour Gobelin
    sg_gob = SliderGrid(
        fig[3,1],
        (label="Gob PV", range=0:500, startvalue=pv_gob[]),
        (label="Gob ATK", range=0:100, startvalue=atk_gob[]),
        (label="Gob DEF", range=0:100, startvalue=def_gob[])
    )
    sPV_gob, sATK_gob, sDEF_gob = sg_gob.sliders
    on(sPV_gob.value)  do v pv_gob[] = v; update_lines!() end
    on(sATK_gob.value) do v atk_gob[] = v; update_lines!() end
    on(sDEF_gob.value) do v def_gob[] = v; update_lines!() end

    # Initialiser le graphique
    update_lines!()

    return Bonito.DOM.div(
        Bonito.DOM.h3("Simulateur : Jed vs Gobelin"),
        sg_jed,
        sg_gob,
        fig
    )
end

Bonito.DOM.div(
    Bonito.DOM.h2("Simulation de PV interactive"),
    interactive_pv_simulation()
)

```
```julia (editor=true, logging=false, output=true)
using Bonito
using WGLMakie
using Observables

WGLMakie.activate!(; resize_to_body=true)

function interactive_pv_simulation()
    # Observables pour Jed
    pv_jed  = Observable(100)
    atk_jed = Observable(30)
    def_jed = Observable(10)

    # Observables pour Gobelin
    pv_gob  = Observable(120)
    atk_gob = Observable(25)
    def_gob = Observable(5)

    # Observables pour les lignes
    xdata = Observable(Float64[])
    ydata_jed = Observable(Float64[])
    ydata_gob = Observable(Float64[])

    # Figure principale
    fig = Figure(resolution = (900, 600), layout = GridLayout())
    
    # Graphique (ligne 1)
    ax = Axis(fig[1,1], title="Évolution des PV", xlabel="Round", ylabel="PV",
              limits=((0,3), (0, max(pv_jed[], pv_gob[])+50)))
    
    # Lignes de PV
    line_jed = lines!(ax, xdata, ydata_jed; color=:blue, linewidth=2)
    line_gob = lines!(ax, xdata, ydata_gob; color=:red, linewidth=2)
    
    # Légende
    Legend(fig[1,2], [line_jed, line_gob], ["Jed (Archer)", "Gobelin"])

    # Fonction PV par round (3 rounds)
    function compute_pv_traj(pv, atk, defn; rounds=3)
        traj = Float64[]
        current = pv
        push!(traj, current)
        for r in 1:rounds
            dmg = max(0, atk - defn)
            current = max(current - dmg, 0)
            push!(traj, current)
        end
        return 0:rounds, traj
    end

    # Mise à jour réactive
    function update_lines!()
        rounds, traj_jed = compute_pv_traj(pv_jed[], atk_gob[], def_jed[], rounds=3)
        _, traj_gob = compute_pv_traj(pv_gob[], atk_jed[], def_gob[], rounds=3)
        xdata[] = collect(rounds)
        ydata_jed[] = traj_jed
        ydata_gob[] = traj_gob
        # Ajuster limites Y pour dézoom automatique
        new_max = max(max(traj_jed...), max(traj_gob...)) + 20
        ax.limits[] = ((0,3), (0, new_max))
    end

    # SliderGrid pour Jed (ligne 2)
    sg_jed = SliderGrid(
        fig[2,1],
        (label="Jed PV", range=0:500, startvalue=pv_jed[]),
        (label="Jed ATK", range=0:100, startvalue=atk_jed[]),
        (label="Jed DEF", range=0:100, startvalue=def_jed[])
    )
    sPV_jed, sATK_jed, sDEF_jed = sg_jed.sliders
    on(sPV_jed.value)  do v pv_jed[] = v; update_lines!() end
    on(sATK_jed.value) do v atk_jed[] = v; update_lines!() end
    on(sDEF_jed.value) do v def_jed[] = v; update_lines!() end

    # SliderGrid pour Gobelin (ligne 3)
    sg_gob = SliderGrid(
        fig[3,1],
        (label="Gob PV", range=0:500, startvalue=pv_gob[]),
        (label="Gob ATK", range=0:100, startvalue=atk_gob[]),
        (label="Gob DEF", range=0:100, startvalue=def_gob[])
    )
    sPV_gob, sATK_gob, sDEF_gob = sg_gob.sliders
    on(sPV_gob.value)  do v pv_gob[] = v; update_lines!() end
    on(sATK_gob.value) do v atk_gob[] = v; update_lines!() end
    on(sDEF_gob.value) do v def_gob[] = v; update_lines!() end

    # Initialiser le graphique
    update_lines!()

    return Bonito.DOM.div(
        Bonito.DOM.h3("Simulateur : Jed vs Gobelin"),
        fig,
        Bonito.DOM.h3("Paramètres Jed"),
        sg_jed,
        Bonito.DOM.h3("Paramètres Gobelin"),
        sg_gob
    )
end

Bonito.DOM.div(
    Bonito.DOM.h2("Simulation de PV interactive"),
    interactive_pv_simulation()
)

```
